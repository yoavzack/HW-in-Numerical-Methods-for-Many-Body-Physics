---
title: "Numerical Methods for Manu Body Physics, Assignment #1"
author: "Yoav Zack"
date: today
format:
  html:
    theme: 
      light: united
      dark: darkly
    code-annotations: hover
    mainfont: "Latin Modern Roman Bold"
    monofont: "JetBrains Mono"
    code-fold: true
---

```{julia}
#| output: false
#| echo: false
#| label: imports-and-constants
using LinearAlgebra
using Random
using Plots
using Printf
using SparseArrays
using Arpack
using LsqFit


theme(:dracula)
# theme(:default)
default(background_color=:transparent, dpi=300)

rng = MersenneTwister(42);
```

In this assignment we will work on the $(J_1,J_2)$ spin-$\frac{1}{2}$ extension to the [Heisenberg model](https://en.wikipedia.org/wiki/Quantum_Heisenberg_model), which is sometimes called the [J1-J2 Model](https://en.wikipedia.org/wiki/J1_J2_model):

$$
H = J_1 \sum_{i} \vec{S}_{i} \cdot \vec{S}_{i+1} + J_{2} \sum_{i}\vec{S}_{i} \cdot \vec{S}_{i+2}
$$

We assume $J_1 >0, J_2 \geq 0$ and denote $g = J_2/J_1$.

# Question #0: Warm Up

We assume $J_2=0$ as required, thus the Hamiltonian is the Heisenberg one:

$$
H = J_1 \sum_{i} \vec{S}_{i} \cdot \vec{S}_{i+1} = J_{1} \sum_{\left<i,j\right>} \left[\frac{1}{2}(\sigma^+_i \sigma^-_j + \sigma^-_i \sigma^+_j) +\frac{1}{4} \sigma^z_i \sigma^z_j \right]
$$

This means the for each pair of adjacent spins $i,j$, the state $\ket{\psi}$ turns into a sum of two elements:

1. A state with switched places for all pairs of opposite spins, with coefficient $-\frac{J_1}{2}$.
2. The same state as $\ket{\psi}$, with a coefficient $\frac{J_1}{4}$ and also a sum over all pairs of adjacent spins, $+1$ for ++/-- and $-1$ for +-/-+.

Note that this means that the state $\ket{\psi}$ of the system must be represented as an array of real numbers, each on corresponding to the coefficient of a single pure state in the superposition, while each pure state is still a single `UInt`. We can convert from the index of a state to itself using the following function:

```{julia}
#| output: false
#| label: function-index-to-state
function index2state(stateInd::Integer, N::Integer)
  return digits(stateInd, base=2, pad=N)
end
```

And now that we have that, we will use it to calculate the effect of the Hamiltonian on a general wave function:

```{julia}
#| output: false
#| label: function-heisenberg-hamiltonian
function multiply_heisenberg(ψ::Vector{<:Number}, J1::Real)
  @assert abs(norm(ψ) - 1) < 1e-9 "Input state is not normalized" # <1>
  D = length(ψ) # <1>
  @assert ispow2(D) "Input state has invalid number of elements" # <1>
  N = Int(log2(D)) # <1>
  @assert mod(N,2)==0 "Only even number of spins is supported" # <1>

  ψ_out = zeros(D)
  for stateInd in range(0, length=D)
    state = index2state(stateInd, N)
    for (i, si) in enumerate(state)
      si = si*2-1 # <2>
      j = mod(i,N)+1 # <2>
      sj = state[j]*2-1 # <2>
      if si == sj
        ψ_out[stateInd+1] += J1/4 # <3>
      else
        ψ_out[stateInd+1] -= J1/4 # <3>
        ψ_out[stateInd+1] -= J1/2 # <4>
      end
    end
  end
  ψ_out = normalize!(ψ_out.*ψ) # <5>
  return ψ_out
end
```
1. Parse Space size and number of spins from wave-function
2. Get the $i$-th and $j$-th spins as +1/-1
3. Calculate effect of $\sigma_i^z \sigma_j^z$ on $\psi$
4. Calculate effect of $\frac{1}{2}(\sigma^+_i \sigma^-_j + \sigma^-_i \sigma^+_j)$ on $\psi$
5. Normalize state (the Hamiltonian above is not normalized)

Let's check it on a simple case:

```{julia}
#| label: fig-repeated-test
#| fig-cap: "Test case of the Hamiltonian function"
N = 6
D = 2^N
count = 10000
ψ = normalize(rand(rng,D))
plot(ψ, label="Original ψ")
for ind in range(0, length=count)
  ψ = multiply_heisenberg(ψ, 1.0)
end
plot!(ψ, label=@sprintf("%d Applications of H", count))
title!("Evolution over Hamiltonian Applications")
```

We will calculate the energy of the ground state and of the output state, and see that the output state approaches the ground state.

The ground state for $N$ spins in a Heisenberg chain is Ferromagnetic for $J<0$ and Antiferromagnetic for $J>0$, i.e. the Néel State. So the function which generates the ground state is the following:

```{julia}
#| output: false
#| label: function-neel-state
#| fig-cap: "Test case of Néel State"
function neel_state(N::Integer, J::Real)
  @assert N>0 "Spin count must be positive"
  @assert J != 0 "Coupling constant cannot be zero"
  D = 2^N

  ψ = zeros(D)
  stateInd = 0
  for spinInd in range(0, length=N)
    if J > 0 && mod(spinInd, 2) == 0
      continue
    end
    stateInd += 2^spinInd
  end
  ψ[stateInd] = 1
  return ψ
end
```

We can test it using a simple test case:

```{julia}
#| label: fig-neel-test
J = 1.0
N = 6
ψ = neel_state(N, J)
maxVal, maxInd = findmax(ψ)
state = index2state(maxInd, N)
plot(ψ, label="Heisenberg State")
```

To compare the energy of this state to the one we got by repeatedly applying the Hamiltonian we need a function to calculate the energy of a state:

```{julia}
#| output: false
#| label: function-energy-of-state
function state_energy(ψ::Vector{<:Number})
  return ψ'⋅multiply_heisenberg(ψ, 1.0)
end
```

Using it we can calculate the energy after repeatedly applying the Hamiltonian and see that it converges to the ground state energy:

```{julia}
#| label: test-energies
J = 1.0
N = 12
ψ = normalize(rand(rng,2^N))
ψ_Neel = neel_state(N, J)

iter_num = 50
E_rng = zeros(iter_num)
E_Neel = zeros(iter_num)
for ind in range(1, length=iter_num)
  ψ = multiply_heisenberg(ψ, 1.0);
  E_rng[ind] = state_energy(ψ)
  E_Neel[ind] = state_energy(ψ_Neel)
end

plot(E_rng .- E_Neel , label="", yaxis=:log)
title!("Energy Difference over repeated applications of H")
xlabel!("Application Count")
ylabel!("Energy Difference")
```

And we can see that the energy of the state goes towards the energy of the Néel State, as expected.

# Question #1: Hamiltonian for $g\neq0$

To extend the given Hamiltonian, first we need to define the same fixed $S_z$ basis as in the tutorial:

```{julia}
#| label: struct-fixed-spin-basis
struct FixedSzBasis
    N::Int64
    Nup::Int64
    states::Vector{Int64}
    
    function FixedSzBasis(N::Int, Nup::Int)
        Ndown = N - Nup
        D = binomial(N, Nup)
        states = zeros(Int, D)
        k=1
        for a in range(0, length = 2^N) # loop over all basis states
            if count_ones(a) == Nup
                states[k] = a
                k += 1
            end
        end
        new(N, Nup, states)
    end
end
```

It also requires helper functions as:

```{julia}
#| label: function-length-basis
#| output: false
import Base.length
function length(b::FixedSzBasis)
    return length(b.states)
end
```

and:

```{julia}
#| label: function-total-spin
#| output: false
function Sz(b::FixedSzBasis)
    Ndown = b.N - b.Nup
    return (b.Nup-Ndown)/2
end
```

and also:

```{julia}
#| label: function-flip-spins
#| output: false
function flipspins(x,i,j)
    f = typeof(x)(1)<<(i-1) | typeof(x)(1)<<(j-1) 
    return x ⊻ f
end
```


Using this basis, we can define the new Hamiltonian Matrix for $g\neq0$:

```{julia}
#| label: function-g-hamiltonian
#| output: false
function construct_g_hamiltonian(basis::FixedSzBasis, J1::Real, J2::Real)
    D = length(basis)
    H = spzeros(D,D)
    
    for k in range(1, length = D)        
        a = basis.states[k]
        for i in range(1, length = basis.N)
            j = mod(i,basis.N)+1
            h = mod(mod(i,basis.N)+1, basis.N)+1
            si = ( a & 1<<(i-1) ) >> (i-1)
            sj = ( a & 1<<(j-1) ) >> (j-1)
            sh = ( a & 1<<(h-1) ) >> (h-1)

            if si == sj
                H[k,k] += J1/4
            else
                H[k,k] += - J1/4
                b = flipspins(a,i,j)
                l = searchsortedfirst(basis.states,b)
                @assert (l<=D) && (basis.states[l] == b) "Invalid basis state generated by flipspins"
                H[k,l] = 1/2
            end

            if si == sh
                H[k,k] += J2/4
            else
                H[k,k] += - J2/4
                b = flipspins(a,i,h)
                l = searchsortedfirst(basis.states,b)
                @assert (l<=D) && (basis.states[l] == b) "Invalid basis state generated by flipspins"
                H[k,l] = 1/2
            end
        end
    end
    
    return H
end
```

Let's test it on a few simple cases of $6$ spins with $N_{\uparrow}=1$:

1. Ground state of $J_1=0, J_2 > 0$
2. 

The matrices are:

```{julia}
#| layout-ncol: 3
#| code-fold: false
#| label: fig-test-g-hamiltonian
#| fig-cap: "Heatmap plot of H for three different cases"
#| fig-subcap:
#|   - "$J_1 = 0, J_2 = 1$"
#|   - "$J_1 = 1, J_2 = 1$"
#|   - "$J_1 = 1, J_2 = 0$"
N = 10
Nup = 5
b = FixedSzBasis(N, Nup)
H1 = construct_g_hamiltonian(b, 0, 1)
H2 = construct_g_hamiltonian(b, 1, 1)
H3 = construct_g_hamiltonian(b, 0, 0)

display(heatmap(H1, size=(230,230), legend=false))
display(heatmap(H2, size=(230,230), legend=false))
display(heatmap(H3, size=(230,230), legend=false))
```