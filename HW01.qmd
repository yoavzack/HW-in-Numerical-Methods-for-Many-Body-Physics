---
title: "Numerical Methods for Manu Body Physics, Assignment #1"
author: "Yoav Zack"
date: today
format:
  html:
    theme: 
      light: united
      dark: darkly
    code-annotations: hover
    mainfont: "Alef"
    monofont: "JetBrains Mono"
    code-fold: false
---

```{julia}
#| output: false
#| echo: false
#| label: imports-and-constants
using LinearAlgebra
using Random
using Plots
using Printf

theme(:dracula)
# theme(:default)
default(background_color=:transparent, dpi=300)

rng = MersenneTwister(42);
```

```{julia}
#| echo: false
#| output: false
#| label: function-flip-spins
function FlipSpins(x::Integer, i::Integer, j::Integer)
  f = typeof(x)(1) << (i-1) | typeof(x)(1) << (j-1) # <1>
  return x ⊻ f
end

function bitarr2int(arr::Vector{<:Integer})
  return sum(arr .* (2 .^ collect(0:length(arr)-1))) # <2>
end
```
1. Given in the tutorial
2. Copied from [here](https://discourse.julialang.org/t/parse-an-array-of-bits-bitarray-to-an-integer/42361/2)

In this assignment we will work on the $(J_1,J_2)$ spin-$\frac{1}{2}$ extension to the [Heisenberg model](https://en.wikipedia.org/wiki/Quantum_Heisenberg_model), which is sometimes called the [J1-J2 Model](https://en.wikipedia.org/wiki/J1_J2_model):

$$
H = J_1 \sum_{i} \vec{S}_{i} \cdot \vec{S}_{i+1} + J_{2} \sum_{i}\vec{S}_{i} \cdot \vec{S}_{i+2}
$$

We assume $J_1 >0, J_2 \geq 0$ and denote $g = J_2/J_1$.

# Question #0: Warm Up

We assume $J_2=0$ as required, thus the Hamiltonian is the Heisenberg one:

$$
H = J_1 \sum_{i} \vec{S}_{i} \cdot \vec{S}_{i+1} = J_{1} \sum_{\left<i,j\right>} \left[\frac{1}{2}(\sigma^+_i \sigma^-_j + \sigma^-_i \sigma^+_j) +\frac{1}{4} \sigma^z_i \sigma^z_j \right]
$$

This means the for each pair of adjacent spins $i,j$, the state $\ket{\psi}$ turns into a sum of two elements:

1. A state with switched places for all pairs of opposite spins, with coefficient $-\frac{J_1}{2}$.
2. The same state as $\ket{\psi}$, with a coefficient $\frac{J_1}{4}$ and also a sum over all pairs of adjacent spins, $+1$ for ++/-- and $-1$ for +-/-+.

Note that this means that the state $\ket{\psi}$ of the system must be represented as an array of real numbers, each on corresponding to the coefficient of a single pure state in the superposition, while each pure state is still a single `UInt`. We can convert from the index of a state to itself using the following function:

```{julia}
#| output: false
#| label: function-index-to-state
function index2state(stateInd::Integer, N::Integer)
  return digits(stateInd, base=2, pad=N)
end
```

And now that we have that, we will use it to calculate the effect of the Hamiltonian on a general wave function:

```{julia}
#| output: false
#| label: function-heisenberg-hamiltonian
function multiply_heisenberg(ψ::Vector{<:Number}, J1::Real)
  @assert abs(norm(ψ) - 1) < 1e-9 "Input state is not normalized" # <1>
  D = length(ψ) # <1>
  @assert ispow2(D) "Input state has invalid number of elements" # <1>
  N = Int(log2(D)) # <1>
  @assert mod(N,2)==0 "Only even number of spins is supported" # <1>

  ψ_out = zeros(D)
  for stateInd in range(0, length=D)
    state = index2state(stateInd, N)
    for (i, si) in enumerate(state)
      si = si*2-1 # <2>
      j = mod(i,N)+1 # <2>
      sj = state[j]*2-1 # <2>
      if si == sj
        ψ_out[stateInd+1] += J1/4 # <3>
      else
        ψ_out[stateInd+1] -= J1/4 # <3>
        # stateIndNew = FlipSpins(stateInd, i, j) # <4>
        ψ_out[stateInd+1] -= J1/2 # <4>
      end
    end
  end
  ψ_out = normalize!(ψ_out.*ψ) # <5>
  return ψ_out
end
```
1. Parse Space size and number of spins from wave-function
2. Get the $i$-th and $j$-th spins as +1/-1
3. Calculate effect of $\sigma_i^z \sigma_j^z$ on $\psi$
4. Calculate effect of $\frac{1}{2}(\sigma^+_i \sigma^-_j + \sigma^-_i \sigma^+_j)$ on $\psi$
5. Normalize state (the Hamiltonian above is not normalized)

Let's check it on a simple case:

```{julia}
#| label: fig-repeated-test
#| fig-cap: "Test case of the Hamiltonian function"
N = 6
D = 2^N
count = 10000
ψ = normalize(rand(rng,D))
plot(ψ, label="Original ψ")
for ind in range(0, length=count)
  ψ = multiply_heisenberg(ψ, 1.0)
end
plot!(ψ, label=@sprintf("%d Applications of H", count))
title!("Evolution over Hamiltonian Applications")
```

We will calculate the energy of the ground state and of the output state, and see that the output state approaches the ground state.


We will also need a function which generates the ground state, which is a dimer state. Since this is a product of dimers of the kind $\ket{\uparrow \downarrow}-\ket{\downarrow \uparrow}$ the final state will have all of the possible combinations of pairs: up-down or down-up for each pair. The weight of them will be equal, but the sign will flip with each addition of down-up pair. All of this is summarized in the following function:

```{julia}
#| output: false
#| label: function-dimer-state
#| fig-cap: "Test case of Dimer States"
function dimer_state(N::Integer)
  @assert N>0 "Number of spins must be positive" # <1>
  @assert mod(N,2)==0 "Currently only even number of spins is supported" # <1>

  D = 2^N
  ψ_p = zeros(D)
  ψ_m = zeros(D)
  for stateInd in range(0, length=2^Int(N/2)) # <2>
    pairs = index2state(stateInd, Int(N/2))
    # print(stateInd, "->", pairs, "->")
    index_p = 0
    index_m = 0
    sign = 1
    for (pairInd, pair) in enumerate(pairs)
      index_p += 2^(2*(pairInd-1)+pair) # <3>
      sign *= 2*pair-1 # <4>
    end
    # print(index_p, index2state(index_p, N), ", ")
    # print(index_m, index2state(index_m, N), "\n")
    index_m = bitarr2int(circshift(index2state(index_p, N), 1)) # <5>
    ψ_p[index_p+1] += sign # <6>
    ψ_m[index_m+1] += sign # <6>
  end
  return [normalize(ψ_p .+ ψ_m), normalize(ψ_p .- ψ_m)] # <7>
end
```
1. Assert the inputs are correct
2. Loop over all possible states for each pair of spins (up-down or down-up)
3. Insert the pair state into the final state by increasing the index either by up-down pair or by down-up pair, according to the pair state
4. Multiply sign by a minus for every up-down pair
5. Take the final state and shift by one, this is the other ground dimer state.
6. Add this spin-state into the total wave-function
7. The final states are the symmetrical and anti-symmetrical sums of the dimers.

We can create a test case:

```{julia}
#| label: fig-dimer-test
(ψ_Dimer_p, ψ_Dimer_m) = dimer_state(N)
plot(ψ_Dimer_p, label="Dimer Dimer +")
plot!(ψ_Dimer_m, label="Dimer State -")
```

On the other hand the **classical** ground state for $N$ spins in chain is Ferromagnetic for $J<0$ and Antiferromagnetic for $J>0$, i.e. the Néel State. So the function which generates the ground state is the following:

```{julia}
#| output: false
#| label: function-neel-state
#| fig-cap: "Test case of Néel State"
function neel_state(N::Integer, J::Real)
  @assert N>0 "Spin count must be positive"
  @assert J != 0 "Coupling constant cannot be zero"
  D = 2^N

  ψ = zeros(D)
  stateInd = 0
  for spinInd in range(0, length=N)
    if J > 0 && mod(spinInd, 2) == 0
      continue
    end
    stateInd += 2^spinInd
  end
  ψ[stateInd] = 1
  return ψ
end
```

I promise this is the last test case for now:
```{julia}
#| label: fig-neel-test
J = 1.0
N = 6
ψ = neel_state(N, J)
maxVal, maxInd = findmax(ψ)
state = index2state(maxInd, N)
plot(ψ, label="Heisenberg State")
```

Let's use all of those together to verify the repeatedly-applied-upon state actually gets closer to the ground state. First we need a function to calculate the energy of a state:

```{julia}
#| output: false
#| label: function-energy-of-state
function state_energy(ψ::Vector{<:Number})
  return ψ'⋅multiply_heisenberg(ψ, 1.0)
end
```

And now we can use it to compare the states:

```{julia}
#| label: test-energies
J = 1.0
N = 12
ψ = normalize(rand(rng,2^N))
(ψ_Dimer_p, ψ_Dimer_m) = dimer_state(N)
ψ_Neel = neel_state(N, J)
# print(2^N, " ", length(ψ), " ", length(ψ_dim), "\n")

iter_num = 50
E_rng = zeros(iter_num)
E_Dimer_p = zeros(iter_num)
E_Dimer_m = zeros(iter_num)
E_Neel = zeros(iter_num)
for ind in range(1, length=iter_num)
  ψ = multiply_heisenberg(ψ, 1.0);
  E_rng[ind] = state_energy(ψ)
  E_Dimer_p[ind] = state_energy(ψ_Dimer_p)
  E_Dimer_m[ind] = state_energy(ψ_Dimer_m)
  E_Neel[ind] = state_energy(ψ_Neel)
end
print(E_rng[iter_num], " ", E_Dimer_p[iter_num], " ", E_Dimer_m[iter_num], " ", E_Neel[iter_num], "\n")
plot(E_rng, label="Repeated Applications")
plot!(E_Dimer_p, label="Dimer State +")
plot!(E_Dimer_m, label="Dimer State -")
plot!(E_Neel, label="Neel State")
title!("Energy over repeated applications of H")
xlabel!("Application Count")
ylabel!("Energy of State")
```

And we can see that the energy of the state goes towards the energy of the Néel State, which is the ground state of the system.

# Question #1: 