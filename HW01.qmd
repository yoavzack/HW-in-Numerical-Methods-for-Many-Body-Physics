---
title: "Numerical Methods for Manu Body Physics, Assignment #1"
author: "Yoav Zack"
date: today
format:
  html:
    theme: 
      light: united
      dark: darkly
    code-annotations: hover
    mainfont: "Latin Modern Roman Bold"
    monofont: "JetBrains Mono"
    code-fold: true
---

```{julia}
#| output: false
#| echo: false
#| label: imports-and-constants
using LinearAlgebra
using Random
using Plots
using Printf
using SparseArrays
using Arpack
using LsqFit


theme(:dracula)
# theme(:default)
default(background_color=:transparent, dpi=300)

rng = MersenneTwister(42);
```

In this assignment we will work on the $(J_1,J_2)$ spin-$\frac{1}{2}$ extension to the [Heisenberg model](https://en.wikipedia.org/wiki/Quantum_Heisenberg_model), which is sometimes called the [J1-J2 Model](https://en.wikipedia.org/wiki/J1_J2_model):

$$
H = J_1 \sum_{i} \vec{S}_{i} \cdot \vec{S}_{i+1} + J_{2} \sum_{i}\vec{S}_{i} \cdot \vec{S}_{i+2}
$$

We assume $J_1 >0, J_2 \geq 0$ and denote $g = J_2/J_1$.

# Question #0: Warm Up

We assume $J_2=0$ as required, thus the Hamiltonian is the Heisenberg one:

$$
H = J_1 \sum_{i} \vec{S}_{i} \cdot \vec{S}_{i+1} = J_{1} \sum_{\left<i,j\right>} \left[\frac{1}{2}(\sigma^+_i \sigma^-_j + \sigma^-_i \sigma^+_j) +\frac{1}{4} \sigma^z_i \sigma^z_j \right]
$$

This means the for each pair of adjacent spins $i,j$, the state $\ket{\psi}$ turns into a sum of two elements:

1. A state with switched places for all pairs of opposite spins, with coefficient $-\frac{J_1}{2}$.
2. The same state as $\ket{\psi}$, with a coefficient $\frac{J_1}{4}$ and also a sum over all pairs of adjacent spins, $+1$ for ++/-- and $-1$ for +-/-+.

Note that this means that the state $\ket{\psi}$ of the system must be represented as an array of real numbers, each on corresponding to the coefficient of a single pure state in the superposition, while each pure state is still a single `UInt`. We can convert from the index of a state to itself using the following function:

```{julia}
#| output: false
#| label: function-index-to-state
function index2state(stateind::Integer, N::Integer)
  return digits(stateind, base=2, pad=N)
end
```

And now that we have that, we will use it to calculate the effect of the Hamiltonian on a general wave function:

```{julia}
#| output: false
#| label: function-heisenberg-hamiltonian
function multiply_heisenberg(ψ::Vector{<:Number}, J1::Real)
  @assert abs(norm(ψ) - 1) < 1e-9 "Input state is not normalized" # <1>
  D = length(ψ) # <1>
  @assert ispow2(D) "Input state has invalid number of elements" # <1>
  N = Int(log2(D)) # <1>
  @assert mod(N,2)==0 "Only even number of spins is supported" # <1>

  ψout = zeros(D)
  for stateind in range(0, length=D)
    state = index2state(stateind, N)
    for (i, si) in enumerate(state)
      si = si*2-1 # <2>
      j = mod(i,N)+1 # <2>
      sj = state[j]*2-1 # <2>
      if si == sj
        ψout[stateind+1] += J1/4 # <3>
      else
        ψout[stateind+1] -= J1/4 # <3>
        ψout[stateind+1] -= J1/2 # <4>
      end
    end
  end
  ψout = normalize!(ψout.*ψ) # <5>
  return ψout
end
```
1. Parse Space size and number of spins from wave-function
2. Get the $i$-th and $j$-th spins as +1/-1
3. Calculate effect of $\sigma_i^z \sigma_j^z$ on $\psi$
4. Calculate effect of $\frac{1}{2}(\sigma^+_i \sigma^-_j + \sigma^-_i \sigma^+_j)$ on $\psi$
5. Normalize state (the Hamiltonian above is not normalized)

Let's check it on a simple case:

```{julia}
#| label: fig-repeated-test
#| fig-cap: "Test case of the Hamiltonian function"
N = 6
D = 2^N
count = 10000
ψ = normalize(rand(rng,D))
plot(ψ, label="Original ψ")
for ind in range(0, length=count)
  ψ = multiply_heisenberg(ψ, 1.0)
end
plot!(ψ, label=@sprintf("%d Applications of H", count))
title!("Evolution over Hamiltonian Applications")
```

We will calculate the energy of the ground state and of the output state, and see that the output state approaches the ground state.

The ground state for $N$ spins in a Heisenberg chain is Ferromagnetic for $J<0$ and Antiferromagnetic for $J>0$, i.e. the Néel State. So the function which generates the ground state is the following:

```{julia}
#| output: false
#| label: function-neel-state
#| fig-cap: "Test case of Néel State"
function neel_state(N::Integer, J::Real)
  @assert N>0 "Spin count must be positive"
  @assert J != 0 "Coupling constant cannot be zero"
  D = 2^N
  ψ = zeros(D)

  if J<0
    stateind = sum([2^spinind for spinind in 0:(N-1)])
  else
    stateind = sum([2^spinind for spinind in 0:2:(N-1)])
  end

  ψ[stateind] = 1
  return ψ
end
```

We can test it using a simple test case:

```{julia}
#| label: fig-neel-test
J = 1.0
N = 6
ψ = neel_state(N, J)
maxVal, maxInd = findmax(ψ)
state = index2state(maxInd, N)
plot(ψ, label="Heisenberg State")
```

To compare the energy of this state to the one we got by repeatedly applying the Hamiltonian we need a function to calculate the energy of a state:

```{julia}
#| output: false
#| label: function-energy-of-state
function state_energy(ψ::Vector{<:Number})
  return ψ'⋅multiply_heisenberg(ψ, 1.0)
end
```

Using it we can calculate the energy after repeatedly applying the Hamiltonian and see that it converges to the ground state energy:

```{julia}
#| label: test-energies
J = 1.0
N = 12
ψ = normalize(rand(rng,2^N))
ψNeel = neel_state(N, J)

iternum = 50
Erng = zeros(iternum)
ENeel = zeros(iternum)
for ind in range(1, length=iternum)
  ψ = multiply_heisenberg(ψ, 1.0);
  Erng[ind] = state_energy(ψ)
  ENeel[ind] = state_energy(ψNeel)
end

plot(Erng , label="Repeated Hamiltonian")
plot!(ENeel , label="Néel State")
title!("Energy over repeated applications of H")
xlabel!("Application Count")
ylabel!("Energy")
```

And we can see that the energy of the state goes towards the energy of the Néel State, as expected.

# Question #1: Hamiltonian for $g\neq0$

To extend the given Hamiltonian, first we need to define the same fixed $S_z$ basis as in the tutorial:

```{julia}
#| label: struct-fixed-spin-basis
struct fixed_sz_basis
    N::Int64
    Nup::Int64
    states::Vector{Int64}
    
    function fixed_sz_basis(N::Int, Nup::Int)
      @assert mod(N, 2) == 0 "Number of spins most be even."
      Ndown = N - Nup
      D = binomial(N, Nup)
      states = zeros(Int, D)
      k=1
      for a in range(0, length = 2^N) # loop over all basis states
          if count_ones(a) == Nup
              states[k] = a
              k += 1
          end
      end
      new(N, Nup, states)
    end
end
```

It also requires helper functions:

```{julia}
#| label: function-helper-fixed-sz
#| output: false
import Base.length
function length(b::fixed_sz_basis)
    return length(b.states)
end

function Sz(b::fixed_sz_basis)
    Ndown = b.N - b.Nup
    return (b.Nup-Ndown)/2
end

function flipspins(x,i,j)
    f = typeof(x)(1)<<(i-1) | typeof(x)(1)<<(j-1) 
    return x ⊻ f
end
```

Using this basis, we can create a function which generates a Hamiltonian Matrix for $g\neq0$:

```{julia}
#| label: function-g-hamiltonian
#| output: false
function construct_g_hamiltonian(basis::fixed_sz_basis, J1::Real, J2::Real)
    D = length(basis)
    H = spzeros(D,D)
    
    for k in range(1, length = D)        
        a = basis.states[k]
        for i in range(1, length = basis.N)
            j = mod(i, basis.N)+1
            h = mod(j, basis.N)+1
            si = ( a & 1<<(i-1) ) >> (i-1)
            sj = ( a & 1<<(j-1) ) >> (j-1)
            sh = ( a & 1<<(h-1) ) >> (h-1)

            if si == sj
                H[k,k] += J1/4
            else
                H[k,k] -= J1/4
                b = flipspins(a,i,j)
                l = searchsortedfirst(basis.states,b)
                @assert (l<=D) && (basis.states[l] == b) "Invalid basis state generated by flipspins"
                H[k,l] += J1/2
            end

            if si == sh
                H[k,k] += J2/4
            else
                H[k,k] -= J2/4
                b = flipspins(a,i,h)
                l = searchsortedfirst(basis.states,b)
                @assert (l<=D) && (basis.states[l] == b) "Invalid basis state generated by flipspins"
                H[k,l] += J2/2
            end
        end
    end
    
    return H
end
```

We can name a few interesting cases in which the ground state is easy:

1. The ground state of $J_1 = 0, J_2 > 0$ is an interleaving of two independent Néel States.
2. The ground state of $J_1 > 0, J_2 = 0$ is the original Néel State.
3. The ground states of $J_1 = 2J_2 > 0$ are the Dimer States we already know.
4. The ground state of $J_1 = J_2 > 0$ 

Let's test it on a few simple cases spins with given $N, N_{\uparrow}$:

```{julia}
#| layout-ncol: 4
#| code-fold: false
#| label: fig-test-g-hamiltonian
#| fig-cap: "Heatmap plot of $H$ for three different cases"
#| fig-subcap:
#|   - "$J_1 = 0, J_2 = 1$"
#|   - "$J_1 = 1, J_2 = 0$"
#|   - "$J_1 = 1, J_2 = 1/2$"
#|   - "$J_1 = 1, J_2 = 1$"
N = 6
Nup = 3
b = fixed_sz_basis(N, Nup)
H1 = construct_g_hamiltonian(b, 0, 1)
H2 = construct_g_hamiltonian(b, 1, 0)
H3 = construct_g_hamiltonian(b, 1, 0.5)
H4 = construct_g_hamiltonian(b, 1, 1)

display(heatmap(H1, size=(150,150), legend=false, ticks=nothing))
display(heatmap(H2, size=(150,150), legend=false, ticks=nothing))
display(heatmap(H3, size=(150,150), legend=false, ticks=nothing))
display(heatmap(H4, size=(150,150), legend=false, ticks=nothing))
```

# Question 2: Triplet Gap

In the following questions we will work on the following cases:

```{julia}
#| label: def-g-array
#| output: false
gc = 0.241
garr = [0, gc, 0.42, 0.5]
```

To perform the triplet gap test we will calculate the energy of the ground state for $S^z=0$ and the lowest energy for $S^z=1$:

```{julia}
#| label: calc-triplet-gap
Narr = 8:2:16
J1 = 1.0

E0 = zeros(length(Narr), length(garr))
E1 = zeros(length(Narr), length(garr))
for (Nind, N) in enumerate(Narr)
  b0 = fixed_sz_basis(N, Int(N/2))
  b1 = fixed_sz_basis(N, Int(N/2)+1)
  for (gind, g) in enumerate(garr)
    J2 = g*J1
    H0 = construct_g_hamiltonian(b0, J1, J2)
    H1 = construct_g_hamiltonian(b1, J1, J2)

    res0 = eigs(H0; nev=1, which=:SR, ritzvec=false)[1]
    res1 = eigs(H1; nev=1, which=:SR, ritzvec=false)[1]
    E0[Nind, gind] = res0[1]
    E1[Nind, gind] = res1[1]
  end
end
ΔE = E1 .- E0
```

To verify that the gap is correct, we will plot it as a function of $\frac{1}{N}$ and verify that it is:

1. Goes to zero for $g\leq g_c$
2. Does not go to zero for $g > g_c$

Let's plot:

```{julia}
#| label: fig-fit-gap
@. model(x, a) = a[1] + a[2]*x

plt = plot()
for (gind, g) in enumerate(garr)
  x = 1 ./ Narr
  xh = [1.1 ./ minimum(Narr), 0.0]
  y = ΔE[:, gind]
  fitobj = curve_fit(model, x, y, [0.0,0.0])
  scatter!(x, y, label=@sprintf("g = %1.3f", g), color=palette(:default)[gind])
  plot!(xh, model(xh, coef(fitobj)), label=nothing, color=palette(:default)[gind])
  @printf("For g=%.3f the intercept is %.3f\n", g, coef(fitobj)[1])
end
plot!(xlims=(0, Inf), ylims=(0, Inf))
title!("Fit for ΔE at Thermodynamic Limit")
xlabel!("1/N")
ylabel!("ΔE")
display(plt)
```