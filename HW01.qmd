---
title: "Numerical Methods for Manu Body Physics, Assignment #1"
author: "Yoav Zack"
date: today
format:
  html:
    theme: 
      light: united
      dark: darkly
    code-annotations: hover
    mainfont: "Alef"
    monofont: "JetBrains Mono"
    code-fold: false
---

```{julia}
#| output: false
#| echo: false
#| label: imports-and-constants
using LinearAlgebra
using Random
using Plots
using Printf

theme(:dracula)
# theme(:default)
default(background_color=:transparent, dpi=300)

rng = MersenneTwister(42);
```

In this assignment we will work on the $(J_1,J_2)$ spin-$\frac{1}{2}$ extension to the [Heisenberg model](https://en.wikipedia.org/wiki/Quantum_Heisenberg_model), which is sometimes called the [J1-J2 Model](https://en.wikipedia.org/wiki/J1_J2_model):

$$
H = J_1 \sum_{i} \vec{S}_{i} \cdot \vec{S}_{i+1} + J_{2} \sum_{i}\vec{S}_{i} \cdot \vec{S}_{i+2}
$$

We assume $J_1 >0, J_2 \geq 0$ and denote $g = J_2/J_1$.

# Question #0: Warm Up

We assume $J_2=0$ as required, thus the Hamiltonian is the Heisenberg one:

$$
H = J_1 \sum_{i} \vec{S}_{i} \cdot \vec{S}_{i+1} = J_{1} \sum_{\left<i,j\right>} \left[\frac{1}{2}(\sigma^+_i \sigma^-_j + \sigma^-_i \sigma^+_j) +\frac{1}{4} \sigma^z_i \sigma^z_j \right]
$$

This means the for each pair of adjacent spins $i,j$, the state $\ket{\psi}$ turns into a sum of two elements:

1. A state with switched places for all pairs of opposite spins, with coefficient $-\frac{J_1}{2}$.
2. The same state as $\ket{\psi}$, with a coefficient $\frac{J_1}{4}$ and also a sum over all pairs of adjacent spins, $+1$ for ++/-- and $-1$ for +-/-+.

Note that this means that the state $\ket{\psi}$ of the system must be represented as an array of real numbers, each on corresponding to the coefficient of a single pure state in the superposition, while each pure state is still a single `UInt`. We can convert from the index of a state to itself using the following function:

```{julia}
#| output: false
#| label: function-index-to-state
function index2state(stateInd::Integer, N::Integer)
  return digits(stateInd, base=2, pad=N)
end
```

And now that we have that, we will use it to calculate the effect of the Hamiltonian on a general wave function:

```{julia}
#| output: false
#| label: function-heisenberg-hamiltonian
function multiply_heisenberg(ψ::Vector{<:Number}, J1::Real)
  @assert abs(norm(ψ) - 1) < 1e-9 "Input state is not normalized" # <1>
  D = length(ψ) # <1>
  @assert ispow2(D) "Input state has invalid number of elements" # <1>
  N = Int(log2(D)) # <1>
  @assert mod(N,2)==0 "Only even number of spins is supported" # <1>

  ψ_out = zeros(D)
  for stateInd in range(0, length=D)
    state = index2state(stateInd, N)
    for (i, si) in enumerate(state)
      si = si*2-1 # <2>
      j = mod(i,N)+1 # <2>
      sj = state[j]*2-1 # <2>
      if si == sj
        ψ_out[stateInd+1] += J1/4 # <3>
      else
        ψ_out[stateInd+1] -= J1/4 # <3>
        ψ_out[stateInd+1] -= J1/2 # <4>
      end
    end
  end
  ψ_out = normalize!(ψ_out.*ψ) # <5>
  return ψ_out
end
```
1. Parse Space size and number of spins from wave-function
2. Get the $i$-th and $j$-th spins as +1/-1
3. Calculate effect of $\sigma_i^z \sigma_j^z$ on $\psi$
4. Calculate effect of $\frac{1}{2}(\sigma^+_i \sigma^-_j + \sigma^-_i \sigma^+_j)$ on $\psi$
5. Normalize state (the Hamiltonian above is not normalized)

Let's check it on a simple case:

```{julia}
#| label: fig-repeated-test
#| fig-cap: "Test case of the Hamiltonian function"
N = 6
D = 2^N
count = 10000
ψ = normalize(rand(rng,D))
plot(ψ, label="Original ψ")
for ind in range(0, length=count)
  ψ = multiply_heisenberg(ψ, 1.0)
end
plot!(ψ, label=@sprintf("%d Applications of H", count))
title!("Evolution over Hamiltonian Applications")
```

We will calculate the energy of the ground state and of the output state, and see that the output state approaches the ground state.

The ground state for $N$ spins in a Heisenberg chain is Ferromagnetic for $J<0$ and Antiferromagnetic for $J>0$, i.e. the Néel State. So the function which generates the ground state is the following:

```{julia}
#| output: false
#| label: function-neel-state
#| fig-cap: "Test case of Néel State"
function neel_state(N::Integer, J::Real)
  @assert N>0 "Spin count must be positive"
  @assert J != 0 "Coupling constant cannot be zero"
  D = 2^N

  ψ = zeros(D)
  stateInd = 0
  for spinInd in range(0, length=N)
    if J > 0 && mod(spinInd, 2) == 0
      continue
    end
    stateInd += 2^spinInd
  end
  ψ[stateInd] = 1
  return ψ
end
```

We can test it using a simple test case:

```{julia}
#| label: fig-neel-test
J = 1.0
N = 6
ψ = neel_state(N, J)
maxVal, maxInd = findmax(ψ)
state = index2state(maxInd, N)
plot(ψ, label="Heisenberg State")
```

To compare the energy of this state to the one we got by repeatedly applying the Hamiltonian we need a function to calculate the energy of a state:

```{julia}
#| output: false
#| label: function-energy-of-state
function state_energy(ψ::Vector{<:Number})
  return ψ'⋅multiply_heisenberg(ψ, 1.0)
end
```

Using it we can calculate the energy after repeatedly applying the Hamiltonian and see that it converges to the ground state energy:

```{julia}
#| label: test-energies
J = 1.0
N = 12
ψ = normalize(rand(rng,2^N))
ψ_Neel = neel_state(N, J)

iter_num = 50
E_rng = zeros(iter_num)
E_Neel = zeros(iter_num)
for ind in range(1, length=iter_num)
  ψ = multiply_heisenberg(ψ, 1.0);
  E_rng[ind] = state_energy(ψ)
  E_Neel[ind] = state_energy(ψ_Neel)
end
plot(E_rng .- E_Neel , label="", yaxis=:log)
title!("Energy Difference over repeated applications of H")
xlabel!("Application Count")
ylabel!("Energy Difference")
```

And we can see that the energy of the state goes towards the energy of the Néel State, as expected.

# Question #1: Hamiltonian for $g\neq0$
